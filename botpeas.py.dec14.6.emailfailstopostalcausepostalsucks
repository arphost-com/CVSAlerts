import requests
import datetime
import pathlib
import json
import os
import yaml
import vulners
import smtplib

from os.path import join
from enum import Enum
from discord import Webhook, RequestsWebhookAdapter
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


# CIRCL v5 vulnerability endpoint (working per your curl test)
# Override if needed via env: CIRCL_API_URL
CIRCL_LU_URL = os.getenv("CIRCL_API_URL", "https://cve.circl.lu/api/vulnerability/")

CVES_JSON_PATH = join(pathlib.Path(__file__).parent.absolute(), "output/botpeas.json")
TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

# Defaults if no state file exists
LAST_NEW_CVE = datetime.datetime.now() - datetime.timedelta(days=1)
LAST_MODIFIED_CVE = datetime.datetime.now() - datetime.timedelta(days=1)

KEYWORDS_CONFIG_PATH = join(pathlib.Path(__file__).parent.absolute(), "config/botpeas.yaml")
ALL_VALID = False
DESCRIPTION_KEYWORDS_I = []
DESCRIPTION_KEYWORDS = []
PRODUCT_KEYWORDS_I = []
PRODUCT_KEYWORDS = []


class Time_Type(Enum):
    PUBLISHED = "Published"
    LAST_MODIFIED = "last-modified"


################## LOAD CONFIGURATIONS ####################

def load_keywords():
    """Load keywords from config file."""
    global ALL_VALID
    global DESCRIPTION_KEYWORDS_I, DESCRIPTION_KEYWORDS
    global PRODUCT_KEYWORDS_I, PRODUCT_KEYWORDS

    with open(KEYWORDS_CONFIG_PATH, 'r') as yaml_file:
        keywords_config = yaml.safe_load(yaml_file)
        print(f"Loaded keywords: {keywords_config}")
        ALL_VALID = keywords_config["ALL_VALID"]
        DESCRIPTION_KEYWORDS_I = keywords_config["DESCRIPTION_KEYWORDS_I"]
        DESCRIPTION_KEYWORDS = keywords_config["DESCRIPTION_KEYWORDS"]
        PRODUCT_KEYWORDS_I = keywords_config["PRODUCT_KEYWORDS_I"]
        PRODUCT_KEYWORDS = keywords_config["PRODUCT_KEYWORDS"]


def ensure_state_file():
    """Ensure output/botpeas.json exists so first run always has a state file."""
    os.makedirs(os.path.dirname(CVES_JSON_PATH), exist_ok=True)
    if not os.path.exists(CVES_JSON_PATH):
        with open(CVES_JSON_PATH, 'w') as json_file:
            json.dump({
                "LAST_NEW_CVE": LAST_NEW_CVE.strftime(TIME_FORMAT),
                "LAST_MODIFIED_CVE": LAST_MODIFIED_CVE.strftime(TIME_FORMAT),
            }, json_file)
        print(f"Created state file: {CVES_JSON_PATH}")


def apply_backfill_if_set():
    """
    If BACKFILL_DAYS is set, override LAST_NEW_CVE / LAST_MODIFIED_CVE
    for this run (one-run override).
    """
    global LAST_NEW_CVE, LAST_MODIFIED_CVE
    val = os.getenv("BACKFILL_DAYS")
    if not val:
        return

    try:
        days = int(val)
        if days <= 0:
            return
        backfill_time = datetime.datetime.now() - datetime.timedelta(days=days)
        LAST_NEW_CVE = backfill_time
        LAST_MODIFIED_CVE = backfill_time
        print(f"[BACKFILL] BACKFILL_DAYS={days} -> using start time {backfill_time}")
    except Exception:
        print(f"[BACKFILL] Invalid BACKFILL_DAYS={val!r} (must be int). Ignoring.")


def load_lasttimes():
    """Load last processed times from json file, unless BACKFILL_DAYS is set."""
    global LAST_NEW_CVE, LAST_MODIFIED_CVE

    if os.getenv("BACKFILL_DAYS"):
        apply_backfill_if_set()
        print(f"Last new cve: {LAST_NEW_CVE}")
        print(f"Last modified cve: {LAST_MODIFIED_CVE}")
        return

    try:
        with open(CVES_JSON_PATH, 'r') as json_file:
            cves_time = json.load(json_file)
            LAST_NEW_CVE = datetime.datetime.strptime(cves_time["LAST_NEW_CVE"], TIME_FORMAT)
            LAST_MODIFIED_CVE = datetime.datetime.strptime(cves_time["LAST_MODIFIED_CVE"], TIME_FORMAT)
    except Exception as e:
        # If error, just keep default (today - 1 day)
        print(f"ERROR, using default last times.\n{e}")
        pass

    print(f"Last new cve: {LAST_NEW_CVE}")
    print(f"Last modified cve: {LAST_MODIFIED_CVE}")


def update_lasttimes():
    """Save last processed times in json file."""
    os.makedirs(os.path.dirname(CVES_JSON_PATH), exist_ok=True)
    with open(CVES_JSON_PATH, 'w') as json_file:
        json.dump({
            "LAST_NEW_CVE": LAST_NEW_CVE.strftime(TIME_FORMAT),
            "LAST_MODIFIED_CVE": LAST_MODIFIED_CVE.strftime(TIME_FORMAT),
        }, json_file)


################## SEARCH CVES ####################

def _to_legacy_time(s: str) -> str:
    """
    CIRCL v5 uses ISO8601 like 2025-12-14T23:33:05Z or with fractional seconds.
    Normalize into YYYY-mm-ddTHH:MM:SS (no Z) for TIME_FORMAT parsing.
    """
    if not s:
        return ""
    s = s.strip()
    if s.endswith("Z"):
        s = s[:-1]
    # remove fractional seconds if present
    if "." in s:
        s = s.split(".", 1)[0]
    return s


def get_cves(tt_filter: Time_Type) -> dict:
    """
    Fetch CVEs from CIRCL v5 vulnerability endpoint and normalize them to the legacy
    shape expected by the rest of this script:
      {"results": [ {id, summary, Published, last-modified, cvss, references, vulnerable_configuration}, ... ]}
    """
    try:
        r = requests.get(CIRCL_LU_URL, headers={"Accept": "application/json"}, timeout=30)
        r.raise_for_status()
    except Exception as e:
        print(f"[CIRCL] Request failed: {e}")
        return {"results": []}

    ct = (r.headers.get("Content-Type") or "").lower()
    if "json" not in ct:
        print(f"[CIRCL] Unexpected content-type={ct} status={r.status_code}")
        print(f"[CIRCL] Body first 300 chars: {r.text[:300]!r}")
        return {"results": []}

    try:
        data = r.json()
    except Exception as e:
        print(f"[CIRCL] JSON parse error: {e}")
        print(f"[CIRCL] Body first 300 chars: {r.text[:300]!r}")
        return {"results": []}

    if not isinstance(data, list):
        print(f"[CIRCL] Unexpected JSON type: {type(data)}")
        return {"results": []}

    results = []
    for item in data:
        if not isinstance(item, dict):
            continue

        meta = item.get("cveMetadata") or {}
        cve_id = meta.get("cveId")
        if not cve_id:
            continue

        published = _to_legacy_time(meta.get("datePublished") or "")
        modified = _to_legacy_time(meta.get("dateUpdated") or meta.get("datePublished") or "")

        cna = (item.get("containers") or {}).get("cna") or {}

        # Description / summary
        summary = ""
        for d in (cna.get("descriptions") or []):
            if (d.get("lang") or "").lower().startswith("en"):
                summary = d.get("value") or ""
                break
        if not summary:
            descs = cna.get("descriptions") or []
            if descs:
                summary = descs[0].get("value") or ""

        # References
        refs = []
        for ref in (cna.get("references") or []):
            u = ref.get("url")
            if u:
                refs.append(u)

        # CVSS base score (best effort)
        cvss = None
        for m in (cna.get("metrics") or []):
            cv = m.get("cvssV3_1") or m.get("cvssV3_0") or m.get("cvssV3") or m.get("cvssV2")
            if isinstance(cv, dict) and cv.get("baseScore") is not None:
                cvss = cv.get("baseScore")
                break

        # Affected products (best effort)
        vuln_cfg = []
        for a in (cna.get("affected") or []):
            vendor = (a.get("vendor") or "").strip()
            product = (a.get("product") or "").strip()
            if vendor or product:
                vuln_cfg.append(f"{vendor}:{product}".strip(":"))

        results.append({
            "id": cve_id,
            "cvss": cvss,
            "Published": published,
            "last-modified": modified,
            "summary": summary,
            "references": refs,
            "vulnerable_configuration": vuln_cfg,
        })

    # Note: time filtering is performed later via filter_cves() using tt_filter keys.
    return {"results": results}


def get_new_cves() -> list:
    """Get CVEs that are new."""
    global LAST_NEW_CVE

    cves = get_cves(Time_Type.PUBLISHED)
    filtered_cves, new_last_time = filter_cves(
        cves.get("results", []),
        LAST_NEW_CVE,
        Time_Type.PUBLISHED
    )
    LAST_NEW_CVE = new_last_time
    return filtered_cves


def get_modified_cves() -> list:
    """Get CVEs that have been modified."""
    global LAST_MODIFIED_CVE

    cves = get_cves(Time_Type.LAST_MODIFIED)
    filtered_cves, new_last_time = filter_cves(
        cves.get("results", []),
        LAST_MODIFIED_CVE,
        Time_Type.LAST_MODIFIED
    )
    LAST_MODIFIED_CVE = new_last_time
    return filtered_cves


def filter_cves(cves: list, last_time: datetime.datetime, tt_filter: Time_Type) -> list:
    """Filter by time and keyword rules."""
    filtered_cves = []
    new_last_time = last_time

    for cve in cves:
        try:
            cve_time = datetime.datetime.strptime(cve[tt_filter.value], TIME_FORMAT)
        except Exception:
            continue

        if cve_time > last_time:
            if (
                ALL_VALID
                or is_summ_keyword_present(cve.get("summary", ""))
                or is_prod_keyword_present(str(cve.get("vulnerable_configuration", "")))
            ):
                filtered_cves.append(cve)

        if cve_time > new_last_time:
            new_last_time = cve_time

    return filtered_cves, new_last_time


def is_summ_keyword_present(summary: str):
    """Given the summary check if any keyword is present."""
    return any(w in summary for w in DESCRIPTION_KEYWORDS) or \
        any(w.lower() in summary.lower() for w in DESCRIPTION_KEYWORDS_I)


def is_prod_keyword_present(products: str):
    """Given the products string check if any keyword is present."""
    return any(w in products for w in PRODUCT_KEYWORDS) or \
        any(w.lower() in products.lower() for w in PRODUCT_KEYWORDS_I)


def search_exploits(cve: str) -> list:
    """Given a CVE, search for public exploits (currently disabled like repo)."""
    return []

    # kept for future:
    vulners_api_key = os.getenv('VULNERS_API_KEY')
    if vulners_api_key:
        vulners_api = vulners.Vulners(api_key=vulners_api_key)
        cve_data = vulners_api.searchExploit(cve)
        return [v['vhref'] for v in cve_data]
    else:
        print("VULNERS_API_KEY wasn't configured!")
    return []


#################### GENERATE MESSAGES #########################

def generate_new_cve_message(cve_data: dict) -> str:
    """Generate new CVE message."""
    message = f"ðŸš¨  *{cve_data['id']}*  ðŸš¨\n"
    message += f"ðŸ”®  *CVSS*: {cve_data.get('cvss')}\n"
    message += f"ðŸ“…  *Published*: {cve_data.get('Published')}\n"
    message += "ðŸ““  *Summary*: "
    summary = cve_data.get("summary", "")
    message += summary if len(summary) < 500 else summary[:500] + "..."

    vuln_cfg = cve_data.get("vulnerable_configuration") or []
    if vuln_cfg:
        message += f"\nðŸ”“  *Vulnerable* (_limit to 10_): " + ", ".join(vuln_cfg[:10])

    refs = cve_data.get("references") or []
    if refs:
        message += "\n\nðŸŸ¢ â„¹ï¸  *More information* (_limit to 5_)\n" + "\n".join(refs[:5])

    message += "\n"
    return message


def generate_modified_cve_message(cve_data: dict) -> str:
    """Generate modified CVE message."""
    return (
        f"ðŸ“£ *{cve_data['id']}*(_{cve_data.get('cvss')}_) was modified the "
        f"{cve_data.get('last-modified', '').split('T')[0]} "
        f"(_originally published the {cve_data.get('Published', '').split('T')[0]}_)\n"
    )


def generate_public_expls_message(public_expls: list) -> str:
    """Given the list of public exploits, generate the message."""
    if public_expls:
        return "ðŸ˜ˆ  *Public Exploits* (_limit 20_)  ðŸ˜ˆ\n" + "\n".join(public_expls[:20])
    return ""


#################### EMAIL DIGEST (ONE PER RUN) #########################

def _parse_bool(val: str, default: bool = False) -> bool:
    if val is None:
        return default
    return str(val).strip().lower() in ("1", "true", "yes", "y", "on")


def _parse_recipients(val: str) -> list:
    if not val:
        return []
    return [e.strip() for e in val.split(",") if e.strip()]


def build_email_digest(new_cves: list, modified_cves: list) -> str:
    """Plain text digest body."""
    now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")
    lines = [f"CVSAlerts digest (UTC {now})", ""]

    if new_cves:
        lines += ["NEW CVEs", "=" * 60]
        for c in new_cves:
            lines.append(f"{c.get('id')} | CVSS {c.get('cvss')} | Published {c.get('Published')}")
            s = (c.get("summary") or "").strip()
            if s:
                lines.append(s)
            refs = c.get("references") or []
            if refs:
                lines.append("References:")
                for r in refs[:10]:
                    lines.append(f" - {r}")
            lines.append("")

    if modified_cves:
        lines += ["", "MODIFIED CVEs", "=" * 60]
        for c in modified_cves:
            lines.append(
                f"{c.get('id')} | CVSS {c.get('cvss')} | Modified {c.get('last-modified')} | Published {c.get('Published')}"
            )
            refs = c.get("references") or []
            if refs:
                lines.append("References:")
                for r in refs[:10]:
                    lines.append(f" - {r}")
            lines.append("")

    return "\n".join(lines).strip() + "\n"


def send_email_digest(subject: str, body: str):
    """
    Send ONE email per run. Enable by setting:
      EMAIL_PROVIDER=smtp|sendgrid
      EMAIL_FROM=sender@example.com
      EMAIL_TO=recipient1@example.com,recipient2@example.com

    Optional:
      EMAIL_SUBJECT=custom subject
      EMAIL_SEND_ON_EMPTY=true|false (default false)
    """
    provider = (os.getenv("EMAIL_PROVIDER") or "").strip().lower()
    if not provider:
        return

    email_from = (os.getenv("EMAIL_FROM") or "").strip()
    email_to = _parse_recipients(os.getenv("EMAIL_TO"))

    if not email_from or not email_to:
        print("EMAIL_FROM / EMAIL_TO not configured; skipping email.")
        return

    if not body.strip() and not _parse_bool(os.getenv("EMAIL_SEND_ON_EMPTY"), False):
        return

    if provider == "smtp":
        smtp_host = (os.getenv("SMTP_HOST") or "").strip()
        smtp_port = int(os.getenv("SMTP_PORT") or "587")
        smtp_user = os.getenv("SMTP_USER")
        smtp_pass = os.getenv("SMTP_PASS")
        smtp_tls = _parse_bool(os.getenv("SMTP_TLS"), True)

        if not smtp_host:
            print("SMTP_HOST not configured; skipping SMTP email.")
            return

        msg = MIMEMultipart()
        msg["From"] = email_from
        msg["To"] = ", ".join(email_to)
        msg["Subject"] = subject
        msg.attach(MIMEText(body, "plain", "utf-8"))

        try:
            server = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
            if smtp_tls:
                server.starttls()
            if smtp_user and smtp_pass:
                server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            server.quit()
            print("Email digest sent via SMTP.")
        except Exception as e:
            print(f"ERROR sending SMTP email: {e}")

    elif provider == "sendgrid":
        api_key = os.getenv("SENDGRID_API_KEY")
        if not api_key:
            print("SENDGRID_API_KEY not configured; skipping SendGrid email.")
            return

        payload = {
            "personalizations": [{
                "to": [{"email": e} for e in email_to],
                "subject": subject
            }],
            "from": {"email": email_from},
            "content": [{"type": "text/plain", "value": body}]
        }

        try:
            resp = requests.post(
                "https://api.sendgrid.com/v3/mail/send",
                headers={
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json"
                },
                json=payload,
                timeout=30
            )
            if resp.status_code in (200, 202):
                print("Email digest sent via SendGrid.")
            else:
                print(f"ERROR sending SendGrid email: {resp.status_code} {resp.text}")
        except Exception as e:
            print(f"ERROR sending SendGrid email: {e}")

    else:
        print(f"Unknown EMAIL_PROVIDER='{provider}'. Use 'smtp' or 'sendgrid'.")


#################### SEND MESSAGES #########################

def send_slack_mesage(message: str, public_expls_msg: str):
    slack_url = os.getenv('SLACK_WEBHOOK')
    if not slack_url:
        return

    json_params = {
        "blocks": [
            {
                "type": "section",
                "text": {"type": "mrkdwn", "text": message}
            },
            {"type": "divider"}
        ]
    }

    if public_expls_msg:
        json_params["blocks"].append({
            "type": "section",
            "text": {"type": "mrkdwn", "text": public_expls_msg}
        })

    requests.post(slack_url, json=json_params, timeout=30)


def send_telegram_message(message: str, public_expls_msg: str):
    telegram_bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
    telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID')

    if not telegram_bot_token or not telegram_chat_id:
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    message = message.replace(".", "\\.").replace("-", "\\-").replace("(", "\\(").replace(")", "\\)").replace("_", "").replace("[", "\\[").replace("]", "\\]").replace("{", "\\{").replace("}", "\\}").replace("=", "\\=")
    r = requests.get(
        f'https://api.telegram.org/bot{telegram_bot_token}/sendMessage?parse_mode=MarkdownV2&text={message}&chat_id={telegram_chat_id}',
        timeout=30
    )

    try:
        resp = r.json()
        if not resp.get('ok', False):
            print("ERROR SENDING TO TELEGRAM:", resp)
    except Exception:
        print("ERROR SENDING TO TELEGRAM: Non-JSON response")


def send_discord_message(message: str, public_expls_msg: str):
    discord_webhok_url = os.getenv('DISCORD_WEBHOOK_URL')
    if not discord_webhok_url:
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    message = message.replace("(", "\\(").replace(")", "\\)").replace("_", "").replace("[", "\\[").replace("]", "\\]").replace("{", "\\{").replace("}", "\\}").replace("=", "\\=")
    webhook = Webhook.from_url(discord_webhok_url, adapter=RequestsWebhookAdapter())
    webhook.send(message)


def send_pushover_message(message: str, public_expls_msg: str):
    pushover_device_name = os.getenv('PUSHOVER_DEVICE_NAME')
    pushover_user_key = os.getenv('PUSHOVER_USER_KEY')
    pushover_token = os.getenv('PUSHOVER_TOKEN')

    if not pushover_device_name or not pushover_user_key or not pushover_token:
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    data = {"token": pushover_token, "user": pushover_user_key, "message": message, "device": pushover_device_name}
    try:
        requests.post("https://api.pushover.net/1/messages.json", data=data, timeout=30)
    except Exception as e:
        print("ERROR SENDING TO PUSHOVER:", e)


def send_ntfy_message(message: str, public_expls_msg: str):
    ntfy_url = os.getenv('NTFY_URL')
    ntfy_topic = os.getenv('NTFY_TOPIC')
    ntfy_auth = os.getenv('NTFY_AUTH')

    if not ntfy_url or not ntfy_topic:
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    full_ntfy_url = f"{ntfy_url}/{ntfy_topic}"

    headers = {
        "Title": "New CVE Alert",
        "Priority": "high",
    }

    if ntfy_auth:
        headers["Authorization"] = ntfy_auth

    response = requests.post(full_ntfy_url, data=message.encode('utf-8'), headers=headers, timeout=30)
    if response.status_code != 200:
        print(f"Failed to send ntfy notification: {response.status_code} {response.text}")


#################### MAIN #########################

def main():
    load_keywords()
    ensure_state_file()
    load_lasttimes()

    # Collect for ONE email digest per run
    email_new_cves = []
    email_modified_cves = []

    # New CVEs
    new_cves = get_new_cves()
    new_cves_ids = [ncve['id'] for ncve in new_cves]
    print(f"New CVEs discovered: {new_cves_ids}")

    for new_cve in new_cves:
        email_new_cves.append(new_cve)

        public_exploits = search_exploits(new_cve['id'])
        cve_message = generate_new_cve_message(new_cve)
        public_expls_msg = generate_public_expls_message(public_exploits)

        send_slack_mesage(cve_message, public_expls_msg)
        send_telegram_message(cve_message, public_expls_msg)
        send_discord_message(cve_message, public_expls_msg)
        send_pushover_message(cve_message, public_expls_msg)
        send_ntfy_message(cve_message, public_expls_msg)

    # Modified CVEs
    modified_cves = get_modified_cves()
    modified_cves = [mcve for mcve in modified_cves if mcve['id'] not in new_cves_ids]
    modified_cves_ids = [mcve['id'] for mcve in modified_cves]
    print(f"Modified CVEs discovered: {modified_cves_ids}")

    for modified_cve in modified_cves:
        email_modified_cves.append(modified_cve)

        public_exploits = search_exploits(modified_cve['id'])
        cve_message = generate_modified_cve_message(modified_cve)
        public_expls_msg = generate_public_expls_message(public_exploits)

        send_slack_mesage(cve_message, public_expls_msg)
        send_telegram_message(cve_message, public_expls_msg)
        send_pushover_message(cve_message, public_expls_msg)
        send_ntfy_message(cve_message, public_expls_msg)

    # ONE email per run (digest)
    total = len(email_new_cves) + len(email_modified_cves)
    if total > 0 or _parse_bool(os.getenv("EMAIL_SEND_ON_EMPTY"), False):
        subject = os.getenv("EMAIL_SUBJECT") or f"CVSAlerts: {total} CVEs detected"
        body = build_email_digest(email_new_cves, email_modified_cves) if total > 0 else ""
        send_email_digest(subject, body)

    update_lasttimes()


if __name__ == "__main__":
    main()

